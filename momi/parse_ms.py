
import bisect
import networkx as nx

from .size_history import ConstantHistory, ExponentialHistory, PiecewiseHistory
from autograd.numpy import isnan, exp

import random
import subprocess
import itertools
from collections import Counter
from io import StringIO

from operator import itemgetter

def sfs_list_from_ms(ms_file):
    """
    Read in a file generated by ms, and return a list of the SFS for each locus

    Parameters
    ----------
    ms_file : an open file object containing the output from ms, e.g.
              > ms_file = file('/path/to/file','r')
              > ms_file = momi.simulate_ms('/path/to/ms', demo, 10, 1e-3)
         (the file object state does not get modified by this function)
    
    Returns
    -------
    sfs_list : list of dicts
         list of the observed sfs for each locus, where sfs is a dict
         mapping configs (tuples) to counts (ints or floats)

    See Also
    --------
    simulate_ms : use ms to simulate from a Demography
    """
    if ms_file.tell() != 0:
        raise ValueError("ms_file pointer should be at beginning of file")
    lines = ms_file.readlines()
    ms_file.seek(0) # reset file pointer to beginning of file

    if " -T " in lines[0]:
        ## TODO: implement this
        raise NotImplementedError("Reading SFS from ms file with -T not yet implemented")
    
    # get out n_at_leaves
    n_at_leaves = None
    firstline = lines[0].replace('\ ','\_').split() # don't split up escaped spaces in /ms/path
    for i,flag in enumerate(firstline):
        if flag == "-I":
            n_at_leaves = tuple(int(x) for x in firstline[(i+2):][:int(firstline[i+1])])
            break
    if n_at_leaves is None:
        n_at_leaves = (int(firstline[1]),)
        
    
    def f(x):
        if x == "//":
            f.i += 1
        return f.i
    f.i = 0
    runs = itertools.groupby((line.strip() for line in lines), f)
    next(runs)

    pops_by_lin = []
    for pop in range(len(n_at_leaves)):
        for i in range(n_at_leaves[pop]):
            pops_by_lin.append(pop)

    return [_sfs_from_1_ms_sim(list(lines), len(n_at_leaves), pops_by_lin)
            for i,lines in runs]

def simulate_ms(ms_path, demo, num_loci, mu_per_locus, seeds=None, additional_ms_params="", rescale=True):
    """
    Use ms to simulate from a Demography, and get an open file object containing the output.

    Parameters
    ----------
    ms_path : str
         path to ms or similar program (e.g. scrm)
    demo : Demography
    num_loci : int
         number of independent loci
    mu_per_locus : float
         rate of mutations occurring per generation, per locus
    seeds : optional, iterable
         a list or tuple of 3 seeds
    additional_ms_params : optional, str
         additional commands to append to the ms command, e.g. recombination
    rescale : optional, bool or float
         rescale demography and mutation rate before passing to ms.
         if True (default), rescale by demo.default_N_diploid.

         additional_ms_params is not affected by this parameter, and so
         any flags passed thru additional_ms_params should be in the appropriate
         units, after rescaling

         if additional_ms_params is not specified, then
         rescaling has no effect on the actual dataset, because scaling
         demography and mutation rate cancel each other out.

    Returns
    -------
    ms_file : file
         open readable file object containing the ms output

    See Also
    --------
    sfs_list_from_ms : convert ms file output to a list of SFS
    """
    if rescale is True:
        rescale = demo.default_N_diploid
    elif rescale is False:
        rescale = 1.0

    theta = mu_per_locus * rescale
    
    if any([(x in additional_ms_params) for x in ("-t","-T","seed")]):
        raise IOError("additional_ms_params should not contain -t,-T,-seed,-seeds")

    lins_per_pop = [demo.n_lineages(l) for l in sorted(demo.leaves)]
    n = sum(lins_per_pop)

    ms_args = _to_ms_cmd(demo, rescale)
    if additional_ms_params:
        ms_args = "%s %s" % (ms_args, additional_ms_params)

    if seeds is None:
        seeds = [random.randint(0,999999999) for _ in range(3)]
    seeds = " ".join([str(s) for s in seeds])
    ms_args = "%s -seed %s" % (ms_args, seeds)

    assert ms_args.startswith("-I ")
    ms_args = "-t %g %s" % (theta, ms_args)
    ms_args = "%d %d %s" % (n, num_loci, ms_args)
   
    return run_ms(ms_args, ms_path=ms_path)

def run_ms(ms_args, ms_path):
    """
    Runs the command
    "%s %s" % (ms_path, ms_args)
    and returns the output as a file-like object
    """
    try:
        lines = subprocess.check_output([ms_path] + ms_args.split(),
                                        stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        ## ms gives really weird error codes, so ignore them
        lines = e.output
    return StringIO(lines.decode('unicode-escape'))

def _to_ms_cmd(demo, rescale):
    if rescale is True:
        rescale = demo.default_N_diploid
    elif rescale is False:
        rescale = 1.0
    
    # the events and their data in depth-first ordering
    events = [(e,demo.event_tree.node[e]) for e in nx.dfs_postorder_nodes(demo.event_tree)]
    # add times, and sort according to times; preserve original ordering for same times
    time_event_list = sorted([(d['t'],e,d) for e,d in events],
                             key=itemgetter(0))

    # pre-checking of the leaf populations
    #def is_leaf_event(e):
    #    return len(demo.event_tree[e]) == 0
    def is_sample_event(e):
        return len(e) == 1 and e[0][0] in demo.leaves and e[0][1] == 0
    sample_events = [(t,e,d) for t,e,d in time_event_list if is_sample_event(e)]
    # assert leaf events have no child pops
    #assert all([len(d['child_pops']) == 0 for t,e,d in leaf_events])
    # make sure leafs all start at time 0
    if any([t != 0.0 for t,e,d in sample_events]):
        raise Exception("ms command line doesn't allow for archaic leaf populations")
    # sort leaf events according to their pop labels
    sample_events = sorted(sample_events, key=itemgetter(1))
    
    assert list(sorted(demo.leaves)) == list(e[0][0] for _,e,_ in sample_events)
    
    non_leaf_events = [(t,e,d) for t,e,d in time_event_list if not len(demo.event_tree[e]) == 0]
    #time_event_list = leaf_events + non_leaf_events

   
    # add sample sizes to the command line    
    ret = ["-I %d" % len(demo.leaves)]
    sample_pops = [d['parent_pops'][0] for _,_,d in sample_events]
    pops = {}
    nextpop = 1
    for l in sample_pops:
        ret += [str(demo.n_lineages(l))]
        pops[l[0]] = nextpop
        nextpop += 1
    for l in sample_pops:
        ret += [demo.G.node[l]['model'].ms_cmd(pops[l[0]], 0.0, rescale=rescale)]
       
    for t,e,d in non_leaf_events:
        parent_pops = d['parent_pops']
        child_pops = d['child_pops']
        #assert len(child_pops) == 2 and len(set([c[0] for c in child_pops])) == 2

        if len(parent_pops) == 2:
            c = list(sorted(child_pops.keys()))[0]
            p, = [p for p in parent_pops if p[0] == c[0]]
            ret += ["-es %f %d %f" % (t / rescale, pops[c[0]], demo.G[p][c]['prob'])]
        elif len(parent_pops) == 1:
            p, = parent_pops
            c, = [c for c in child_pops if c[0] != p[0]]
            ret += ["-ej %f %d %d" % (t / rescale, pops[c[0]], pops[p[0]])]
        else:
            assert False

        for p in parent_pops:
            if p[0] not in pops:
                pops[p[0]] = nextpop
                nextpop += 1
            ret += [demo.G.node[p]['model'].ms_cmd(pops[p[0]], t, rescale=rescale)]

    return " ".join(ret)

def _convert_ms_cmd(cmd_list, params):
    cmd_list = list(cmd_list)
    if cmd_list[0][0] != 'I':
        raise IOError("ms command must begin with -I to specify samples per population")
    n_pops = int(cmd_list[0][1])
    
    ## first replace the # sign convention
    pops_by_time = [(0.0, idx) for idx in range(1,n_pops+1)]
    for cmd in cmd_list:
        if cmd[0] == 'es':
            n_pops += 1
            pops_by_time += [(params.time(cmd[1]), n_pops)]
    pops_by_time = [p[1] for p in sorted(pops_by_time, key=itemgetter(0))]

    pops_map = dict(list(zip(pops_by_time, list(range(1, len(pops_by_time)+1)))))
    for cmd in cmd_list:
        for i in range(len(cmd)):
            if cmd[i][0] == "#":
                # replace with pop idx according to time ordering
                cmd[i] = str(pops_map[int(cmd[i][1:])])
    
    ## next sort ms command according to time
    non_events = [cmd for cmd in cmd_list if cmd[0][0] != 'e']
    events = [cmd for cmd in cmd_list if cmd[0][0] == 'e']
    
    time_events = [(params.time(cmd[1]), cmd) for cmd in events]
    time_events = sorted(time_events, key=itemgetter(0))
    
    events = [cmd for t,cmd in time_events]

    cmd_list = non_events + events

    ## next replace flags with their alternative names:
    for cmd in cmd_list:
        if cmd[0] == "I":
            if len(cmd[2:]) != int(cmd[1]):
                raise IOError("Wrong number of arguments for -I (note continuous migration is not allowed)")
            del cmd[1]
            cmd[0] = "n"
        elif cmd[0] in ["es","ej","eg","en"]:
            cmd[0] = cmd[0][1].upper()
        elif cmd[0] in ["n", "g"]:
            cmd[0] = cmd[0].upper()
            cmd.insert(1, "0.0")
        elif cmd[0] in ["eN", "eG"]:
            cmd[0] = cmd[0][1]
            cmd.insert(2, "*")
        elif cmd[0] == "G":
            cmd.insert(1, "0.0")
            cmd.insert(2, "*")
        #cmd[0] = "-" + cmd[0]

    cmd_list = [['d','1']] + cmd_list
    return cmd_list

def _sfs_from_1_ms_sim(lines, num_pops, pops_by_lin):
    currCounts = Counter()
    n = len(pops_by_lin)

    assert lines[0] == "//"
    nss = int(lines[1].split(":")[1])
    if nss == 0:
        return currCounts
    # remove header
    lines = lines[3:]
    # remove trailing line if necessary
    if len(lines) == n+1:
        assert lines[n] == ''
        lines = lines[:-1]
    # number of lines == number of haplotypes
    assert len(lines) == n
    # columns are snps
    for column in range(len(lines[0])):
        dd = [0] * num_pops
        for i, line in enumerate(lines):
            dd[pops_by_lin[i]] += int(line[column])
        assert sum(dd) > 0
        currCounts[tuple(dd)] += 1
    return dict(currCounts)
