#+PROPERTY: header-args:ipython :session :results raw drawer :kernel momi2-gaxri9wx
* Tutorial
  :PROPERTIES:
  :CUSTOM_ID: tutorial
  :END:

This is a tutorial for the =momi= package. You can run the ipython
notebook that created this tutorial at =examples/tutorial.ipynb=.

To get started, import the =momi= package:

#+BEGIN_SRC ipython
    import momi
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1]:
:END:

Some =momi= operations can take awhile complete, so it is useful to turn
on status monitoring messages to check that everything is running
normally. Here, we output logging messages to the file =tutorial.log=.
See the [[https://docs.python.org/3/library/logging.html][logging]]
module for more details.

#+BEGIN_SRC ipython
  import logging
  #logging.basicConfig(level=logging.INFO, filename="tutorial.log")
  logging.basicConfig(level=logging.INFO)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[2]:
:END:


** Constructing a demographic history
   :PROPERTIES:
   :CUSTOM_ID: constructing-a-demographic-history
   :END:

We will construct a demographic model loosely based on human history. To
start, we need to specify =N_e=, which is the size of each population
unless explicitly specified otherwise, and =gen_time=, the amount of
time per generation.

(TODO is =N_e= diploid or haploid???)

We will measure time in years; the human generation time is
approximately =gen_time=29= years per generation. The human effective
population size is typically measured as $1.2 \times 10^{4}$ so we set
=N_e=1.2e4=.

(Note the population size here is NOT the census size, but the
population genetics concept of
[[https://en.wikipedia.org/wiki/Effective_population_size][effective
population size]] or $N_e$).

#+BEGIN_SRC ipython
  model = momi.DemographicModel(N_e=1.2e4, gen_time=29,
                                muts_per_gen=1.25e-8)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[3]:
:END:


We now specify the sampled ("leaf") populations of our demography. We
specify three populations: YRI, CHB, and NEA. YRI and CHB are
present-day populations at $t=0$, while NEA is an archaic population
from $t=50,000$ years ago. We set YRI and NEA to have the default
population sizes, and set CHB to have a size of $N=100,000$ growing at
rate $.0005$ per year.

TODO check is growth rate g or g/2

#+BEGIN_SRC ipython
    # add YRI leaf at t=0 and default_N
    model.add_leaf("YRI")
    # add  CHB leaf at t=0, N=1e5, growing at rate 5e-4 per unit time (year)
    model.add_leaf("CHB", N=1e5, g=5e-4)
    # add NEA leaf at 50kya
    model.add_leaf("NEA", t=5e4) 
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
:END:

Demographic events are added to the model by the methods =set_size()=
and =move_lineages()=. =set_size()= is used to change population size
and growth rate, while =move_lineages()= is used for population split
and admixture events.

#+BEGIN_SRC ipython
    # stop CHB growth at 10kya
    model.set_size("CHB", g=0, t=1e4)

    # at 45kya CHB receive a 3% pulse from GhostNea
    model.move_lineages("CHB", "GhostNea", t=4.5e4, p=.03)
    # at 55kya GhostNea joins onto NEA
    model.move_lineages("GhostNea", "NEA", t=5.5e4)

    # at 80 kya CHB goes thru bottleneck
    model.set_size("CHB", N=100, t=8e4)
    # at 85 kya CHB joins onto YRI
    model.move_lineages("CHB", "YRI", t=8.5e4)

    # at 500 kya YRI joins onto NEA
    model.move_lineages("YRI", "NEA", t=5e5)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:
:END:

If you are familiar with the software
[[http://home.uchicago.edu/rhudson1/source/mksamples.html][ms]],
=set_size()= is analogous to the flags "-en" and "-eg", while
=move_lineages()= is analogous to the flags "-ej" and "-es". If you are
familiar with the package
[[https://msprime.readthedocs.io/en/stable/][msprime]], then
=set_size()= is analogous to =msprime.PopulationParametersChange=, while
=move_lineages()= is analogous to =msprime.MassMigration=.

Note that events can involve other populations aside from the 3 sampled
populations YRI, CHB, and NEA. Unsampled populations are also known as
"ghost populations". In this example, CHB receives a small amount of
admixture from a population "GhostNea", which splits off from NEA at an
earlier date.

** Plotting a demography
   :PROPERTIES:
   :CUSTOM_ID: plotting-a-demography
   :END:

#+BEGIN_SRC ipython
    plt = momi.DemographyPlot(model, ["YRI", "CHB", "GhostNea", "NEA"],
                              figsize=(6,8),
                              major_yticks=[1e4, 2.5e4, 5e4, 7.5e4,
                                            1e5, 2.5e5, 5e5, 7.5e5],
                              linthreshy=1e5, pulse_bounds=(0,.25))
    plt.draw()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[6]:
[[file:./obipy-resources/14551ug.png]]
:END:

Note the user needs to specify the order of all populations (including
ghost populations) along the x-axis.

The argument =linthreshy= is useful for visualizing demographic events
at different scales. In our example, the split time of NEA is far above
the other events. Times below =linthreshy= are plotted on a linear
scale, while times above it are plotted on a log scale.

*** Additional plotting details
    :PROPERTIES:
    :CUSTOM_ID: additional-plotting-details
    :END:

If you are using Python outside a notebook environment, e.g.Â in a shell,
then you need to call the following before making calls to =draw()=:

#+BEGIN_EXAMPLE
    # call first if in a shell not a notebook:
    from matplotlib import pyplot as plt
    plt.ion()
#+END_EXAMPLE

=momi= uses [[https://matplotlib.org/][matplotlib]] for plotting. Users
can make calls to =matplotlib= to adjust various aspects of the
plotting.

TODO simplify the plotting API, make it easier to interact with
matplotlib

** Reading and simulating data
   :PROPERTIES:
   :CUSTOM_ID: reading-and-simulating-data
   :END:

In this section we demonstrate how to read in data from a VCF file.

Before we can read in a dataset we first need to create one. So we start
by demonstrating how to simulate a VCF from our demography, then we read
it in.

*** Simulating data
    :PROPERTIES:
    :CUSTOM_ID: simulating-data
    :END:

#+BEGIN_SRC ipython
  import os

  recoms_per_gen = 1.25e-8
  bases_per_locus = int(5e5)
  n_loci = 20
  ploidy = 2

  # number of alleles to sample per population
  sampled_n_dict = {"NEA":2, "YRI":4, "CHB":4}

  # create data directory if it doesn't exist
  os.makedirs("data", exist_ok=True)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[7]:
:END:


#+BEGIN_SRC ipython
  # simulate 20 "chromosomes", saving each in a separate vcf file
  for chrom in range(n_loci):
        model.simulate_vcf(
              f"data/{chrom}",
              recoms_per_gen=recoms_per_gen,
              length=bases_per_locus,
              chrom_name="chr{}".format(chrom),
              ploidy=ploidy,
              random_seed=1234+chrom,
              sampled_n_dict=sampled_n_dict,
              force=True)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[8]:
:END:


*** read in data from vcf

    
#+BEGIN_SRC ipython
  ## read in data from vcf

  ## first create a dict mapping samples to populations
  ind2pop = {}
  for pop, n in sampled_n_dict.items():
      for i in range(int(n / ploidy)):
          ## in the simulated vcfs, the samples are named like YRI_0, YRI_1, CHB_0, etc
          ind2pop["{}_{}".format(pop, i)] = pop

  # Read in each vcf in a for loop
  data = []
  for chrom in range(n_loci):
      data.append(momi.SnpAlleleCounts.read_vcf(
          f"data/{chrom}.vcf.gz", ind2pop,
          bed_file=f"data/{chrom}.bed",
          ancestral_alleles=True))

  # concatenate the 20 loci into a single dataset
  data = momi.SnpAlleleCounts.concatenate(data)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[9]:
:END:

#+BEGIN_SRC ipython
    ## dump the momi-style data to a gzipped json file
    data.dump("data/momi_data.json.gz")

    ## load the data back from the json file
    data2 = momi.SnpAlleleCounts.load("data/momi_data.json.gz")

    assert data == data2
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[10]:
:END:

#+BEGIN_SRC ipython
  sfs = data2.extract_sfs(n_blocks=100)
  with open("data/foo.txt", "w") as f:
      sfs.dump(f)

  with open("data/foo.txt") as f:
      sfs2 = momi.site_freq_spectrum.load(f)

  sfs2 == sfs
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[11]:
: True
:END:


#+BEGIN_SRC ipython
  ## INFERENCE

  ## create a new model
  model2 = momi.DemographicModel(N_e=1.2e4, gen_time=29,
                                 muts_per_gen=1.25e-8)

  ## set the data
  model2.set_data(sfs)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[12]:
:END:

#+BEGIN_SRC ipython
    ## start by fitting CHB and YRI

    ## define parameters of the model
    #model2.add_size_param("n_chb", 1.2e4)
    #model2.add_growth_param("g_chb", 0, lower=-1e-3, upper=1e-3)
    #model2.add_time_param("t_chb_yri", 1e5, lower=1e4)
    model2.add_size_param("n_chb")
    model2.add_growth_param("g_chb", 0, lower=-1e-3, upper=1e-3)
    model2.add_time_param("t_chb_yri", lower=1e4)

    ## add demographic events
    model2.add_leaf("CHB", N="n_chb", g="g_chb")
    model2.add_leaf("YRI")
    model2.set_size("CHB", t=1e4, g=0)
    model2.move_lineages("CHB", "YRI", t="t_chb_yri")
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[13]:
:END:

#+BEGIN_SRC ipython :async t
    #model2.optimize(method="L-BFGS-B")
    model2.optimize(method="TNC")
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[14]:
#+BEGIN_EXAMPLE
  fun: 0.0013466221737334606
  jac: array([-5.75017364e-05,  2.85030320e-01,  5.57443513e-10])
  message: 'Converged (|f_n-f_(n-1)| ~= 0)'
  nfev: 43
  nit: 16
  parameters: ParamsDict({'n_chb': 18526.892257864765, 'g_chb': 0.0003050757786989606, 't_chb_yri': 115685.45164837231})
  status: 1
  success: True
  x: array([9.82697859e+00, 3.05075779e-04, 1.05685452e+05])
#+END_EXAMPLE
:END:


#+BEGIN_SRC ipython
    model2.get_params()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[15]:
#+BEGIN_EXAMPLE
  ParamsDict([('n_chb', 18526.892257864765),
  ('g_chb', 0.0003050757786989606),
  ('t_chb_yri', 115685.45164837231)])
#+END_EXAMPLE
:END:

#+BEGIN_SRC ipython
    # plot the model
    plt = momi.DemographyPlot(model2, ["YRI", "CHB"],
                              figsize=(6,8), linthreshy=1e5,
                              major_yticks=[1e4, 2.5e4, 5e4, 7.5e4,
                              1e5, 1.25e5],
                              pulse_bounds=(0,.25))
    plt.draw()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[16]:
[[file:./obipy-resources/1455C5m.png]]
:END:


#+BEGIN_SRC ipython
    ## add NEA to the model

    model2.add_leaf("NEA", t=5e4)

    #model2.add_time_param("t_anc", 5e5,
    #                      lower_constraints=["t_chb_yri"])
    model2.add_time_param("t_anc", lower=5e4, lower_constraints=["t_chb_yri"])

    model2.move_lineages("YRI", "NEA", t="t_anc")
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[17]:
:END:

#+BEGIN_SRC ipython :async t
    model2.optimize()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[18]:
#+BEGIN_EXAMPLE
  fun: 0.012567120418911925
  jac: array([-6.67844320e-08, -7.68025159e-04, -2.98708130e-11,  2.03554987e-12])
  message: 'Converged (|f_n-f_(n-1)| ~= 0)'
  nfev: 50
  nit: 14
  parameters: ParamsDict({'n_chb': 1841.2471681874276, 'g_chb': 7.25664489267316e-05, 't_chb_yri': 109500.50203880756, 't_anc': 442978.7398167962})
  status: 1
  success: True
  x: array([7.51819843e+00, 7.25664489e-05, 9.95005020e+04, 3.33478238e+05])
#+END_EXAMPLE
:END:

#+BEGIN_SRC ipython
  # plot the model
  plt = momi.DemographyPlot(model2, ["YRI", "CHB", "NEA"], figsize=(6,8), linthreshy=1e5, major_yticks=[1e4, 2.5e4, 5e4, 7.5e4, 1e5, 2.5e5, 5e5])
  plt.draw()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[19]:
[[file:./obipy-resources/1455PDt.png]]
:END:

#+BEGIN_SRC ipython :results raw drawer
  # model diagnostics
  model_fit_stats = momi.ModelFitStats(model2)
  # f4(YRI, CHB, NEA, AncestralAllele) < 0 because of unmodeled Neanderthal admixture
  # z_score is not significant because we only have a small dataset here
  model_fit_stats.f4("YRI", "CHB", "NEA", None)

  # also some functionality to check other statistics
  # e.g. f2, f3, distance between every pair of populations
  # (TODO: easily plot residuals of all pairwise distances)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
: JackknifeGoodnessFitStat(expected=6.938893903907228e-18, observed=-0.005661024702653249, sd=0.002716661599502775, z_score=-2.0838166607461823)
:END:

#+BEGIN_SRC ipython
    ## create a new model with added NEA->CHB pulse

    add_pulse_model = model2.copy()

    #add_pulse_model.add_pulse_param("p_pulse", .1)
    #add_pulse_model.add_time_param("t_pulse", 5e4, upper_constraints=["t_chb_yri"])
    add_pulse_model.add_pulse_param("p_pulse", upper=.25)
    add_pulse_model.add_time_param("t_pulse", upper_constraints=["t_chb_yri"])

    add_pulse_model.move_lineages("CHB", "GhostNea", t="t_pulse", p="p_pulse")

    #add_pulse_model.add_time_param("t_ghost", 1e5, lower=5e4, lower_constraints=["t_pulse"], upper_constraints=["t_anc"])
    add_pulse_model.add_time_param("t_ghost", lower=5e4, lower_constraints=["t_pulse"], upper_constraints=["t_anc"])
    add_pulse_model.move_lineages("GhostNea", "NEA", t="t_ghost")
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[28]:
:END:

#+BEGIN_SRC ipython :async t
  # stochastic gradient descent (ADAM+SVRG)
  add_pulse_model.stochastic_optimize(snps_per_minibatch=1000, num_iters=10, svrg_epoch=3)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[29]:
#+BEGIN_EXAMPLE
  fun: 3.7190104911306694
  jac: array([ 2.12556560e-02, -2.20290249e+01, -7.62600757e-08, -1.42325507e-07,
  5.12755003e-02, -1.00813058e-04, -3.33314704e-03])
  message: 'Maximum number of iterations reached'
  nit: 9
  success: False
  x: array([ 7.44326709e+00, -1.00000000e-03,  9.95005384e+04,  3.33478731e+05,
  -2.63439732e+00,  1.34345508e+00,  5.70926198e-01])
#+END_EXAMPLE
:END:

#+BEGIN_SRC ipython :async t
    # full gradient descent
    add_pulse_model.optimize(method="TNC")
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[30]:
#+BEGIN_EXAMPLE
  fun: 0.004945928148744051
  jac: array([ 5.40943979e-03, -5.33583325e+01, -4.97477068e-08,  5.65130981e-09,
  2.05264960e-03, -2.15299405e-03,  1.07695169e-04])
  message: 'Max. number of function evaluations reached'
  nfev: 100
  nit: 16
  parameters: ParamsDict({'n_chb': 8920.323737864543, 'g_chb': 0.00028127935049284666, 't_chb_yri': 94275.54269551455, 't_anc': 471939.2204350214, 'p_pulse': 0.06610239563436653, 't_pulse': 29880.5809462377, 't_ghost': 104926.14200154741})
  status: 3
  success: False
  x: array([ 9.09608752e+00,  2.81279350e-04,  8.42755427e+04,  3.77663678e+05,
  -2.64816181e+00, -7.67826594e-01, -1.89940807e+00])
#+END_EXAMPLE
:END:

#+BEGIN_SRC ipython
    # plot the model
    plt = momi.DemographyPlot(add_pulse_model, ["YRI", "CHB", "GhostNea", "NEA"], linthreshy=1e5, figsize=(6,8), major_yticks=[1e4, 2.5e4, 5e4, 7.5e4, 1e5, 2.5e5, 5e5, 7.5e5])
    plt.draw()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[31]:
[[file:./obipy-resources/1455cNz.png]]
:END:


#+BEGIN_SRC ipython :async t
  ## generate nonparametric bootstrap datasets

  n_bootstraps = 5
  #n_bootstraps = 20
  #bootstrap_mles = []

  plt = momi.DemographyPlot(add_pulse_model, ["YRI", "CHB", "GhostNea", "NEA"], linthreshy=1e5, figsize=(6,8), major_yticks=[1e4, 2.5e4, 5e4, 7.5e4, 1e5, 2.5e5, 5e5, 7.5e5])

  #bootstrap_model = add_pulse_model.copy()
  model2_copy = model2.copy()
  add_pulse_copy = add_pulse_model.copy()
  for bootstrap_it in range(n_bootstraps):
      print(bootstrap_it)
      # bootstrap resample blocks
      resampled = sfs.resample()
      model2_copy.set_data(resampled)
      add_pulse_copy.set_data(resampled)

      model2_copy.set_params(randomize=True)
      model2_copy.optimize()
      add_pulse_copy.set_params(model2_copy.get_params(), randomize=True)
      add_pulse_copy.optimize()

      plt.add_bootstrap(add_pulse_copy.get_params(), alpha=1./n_bootstraps)

  plt.draw()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[32]:
[[file:./obipy-resources/1455OXC.png]]
:END:


#+BEGIN_SRC ipython
    plt.figure(figsize=(8,10))
    add_pulse_model.draw_with_bootstraps(bootstrap_mles,
                                         ["YRI", "CHB", "GhostNea", "NEA"], 
                                         linthreshy=1e5, p_min=0, p_max=1)
    plt.gca().set_yticks([1e4, 2.5e4, 5e4, 7.5e4, 1e5, 2.5e5, 5e5])
#+END_SRC

#+BEGIN_EXAMPLE
    /home/jack/pythonpath/momi/demo_plotter.py:35: RuntimeWarning: invalid value encountered in double_scalars
      -self.curr_g * (nxt_t - self.curr_t))





    [<matplotlib.axis.YTick at 0x7f82e1a6e3c8>,
     <matplotlib.axis.YTick at 0x7f82e1a58c88>,
     <matplotlib.axis.YTick at 0x7f82e1a7b518>,
     <matplotlib.axis.YTick at 0x7f82e1a859b0>,
     <matplotlib.axis.YTick at 0x7f82e1aa53c8>,
     <matplotlib.axis.YTick at 0x7f82e1aa5da0>,
     <matplotlib.axis.YTick at 0x7f82e1aa37b8>]
#+END_EXAMPLE

#+CAPTION: png
[[file:tutorial_files/tutorial_35_2.png]]
