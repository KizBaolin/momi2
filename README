TODO:

***
do some speed testing, to see how much autodifferentiation slows stuff down
compare:
1. previous implementation (before adarray)
2. constant case (no derivatives)
3. first order derivatives
4. second order derivatives

***
compare which version of expm_multiply is faster (with and without derivatives)

****
in adarray, make __pow__ work for arrays, for at least some cases
(e.g. if raising an array to a constant power -- having x**-1 would be nice)
in adarray, implement logical_or, logical_and
in adarray, implement allclose

after above changes, do cleanup in size_history, removing array() and num.x calls where possible
also do cleanup in test_size_history with np.allclose

***
make adarray be able to merge back into original project easily

to do this, instead of using ADF class, change ADF to be abstract superclass
old-ad ADF becomes ADScalar
my new ADF becomes ADArray
whenever ADF arithmetic returns something, it calls self.getAD(result) to make
the result be of appropriate type, where ADScalar and ADArray each return their own
getAD

***
make size_history store the SFS as an array,
instead of having sum_product have to convert to an array everytime

***
Make functional size history work with autodifferentiation! Right now assumes it's a constant function always

***
allow for iteration over adarray objects (useful for passing in *array to demography.from_ms)

***
be consistent with leaves vs leafs (leaves is demography property, leafs is argument to parse_ms)