TODO:

***
subclass ndarray, and replace rmul,radd, etc for this subclass!!!!

this will allow arbitrary left,right multiplication etc, and clean up the code a lot! and also allow us to use arbitrary scipy functions, e.g. in the FunctionalTruncatedHistory

***
sometimes return negative numbers for very unlikely datasets
investigate how to fix this

this is likely happening in the matrix exponential.
perhaps, the eigenvalue method has catastrophic cancellation for scaled_time very small.
try comparing expm_multiply and eigenvalue method for different ranges of scaled_time

***
merge admixture branch into autodiff branch

***
fix overflow errors in exponential growth

to do this, use the fact that
exp(x) * exp1(x) (ie exp(x) * expi(-x))
is approximately equal to 1/x when x is large
(see wikipedia)

better yet, can express everything in terms of
exp(1/x) * exp1(1/x) * x
which is approximately 1 when x is very small
(this further allows us to have a growth rate of 0.0 and not fail)!

***
make exponential size history work with growth rate 0, and also tau=0.
Fix parse_ms TODO: for tau==0.0 case

***
for parse ms, let -es specificy the label of the new population
this will be required to avoid confusion over population labels when fitting times of events

***
compare which version of expm_multiply is faster (with and without derivatives)

****
in adarray, make __pow__ work for arrays, for at least some cases
(e.g. if raising an array to a constant power -- having x**-1 would be nice)
in adarray, implement logical_or, logical_and
in adarray, implement allclose

after above changes, do cleanup in size_history, removing array() and num.x calls where possible
also do cleanup in test_size_history with np.allclose

***
make adarray be able to merge back into original project easily

to do this, instead of using ADF class, change ADF to be abstract superclass
old-ad ADF becomes ADScalar
my new ADF becomes ADArray
whenever ADF arithmetic returns something, it calls self.getAD(result) to make
the result be of appropriate type, where ADScalar and ADArray each return their own
getAD

***
make size_history store the SFS as an array,
instead of having sum_product have to convert to an array everytime

***
Make functional size history work with autodifferentiation! Right now assumes it's a constant function always

***
allow for iteration over adarray objects (useful for passing in *array to demography.from_ms)

***
be consistent with leaves vs leafs (leaves is demography property, leafs is argument to parse_ms)

***
clean up from_newick, to_newick in demography.py

Either:
get rid of it entirely
or
change it to use from_ms
or
implement to_ms, so Demography.simulate_sfs() can work for newick demos

***
for simulate_sfs, make theta=None work when -r is set
(right now it counts up the total branch length, but doesn't know
how to deal with multiple trees)

***
replace cached_property module (v1.0.0 not compatible with using nx.DiGraph)
***
make state of derived counts, a property of SumProduct, instead of Demography
***
don't make n_max a field of size_history;
instead have etjj and sfs take n as a parameter, and return
the appropriate vector

***
add option to simulate from ms instead of scrm

***
test timing of second order derivatives
improve syntax for using second order derivatives

***
test in what regime expm_multiply is better than eigenvalue
internally decide which one to use based on the regime

***
test in what regime fft_convolve is better than convolve
internally decide which one to use based on the regime

***
rename SumProduct.p()

***
improve the syntax for SFS.
use dictionary for state instead of tuple? (downside: won't be hashable)
store sumCounts, sumSqCounts, nonzeroCounts in a single object?

***
try autograd package for automatic differentiation

