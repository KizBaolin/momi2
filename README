TODO:

***
Try expokit stuff in expokit branch

***
copy assertions in ConstantTruncatedSizeHistory.etjj to other etjj

***
truncate() call in size_history.py is a little ugly, vectorize it and such
(see TODO)

***
switched to using non-FFT convolve, fix numerical errors with FFT convolve and switch back to it

***
Two sources of numerical error:

1) FFT convolution: when vector has a 0.0 sometimes small negative numbers result
however, in our case the 0.0 is always at the beginning or end of vector
so can make FFT convolution more robust by truncating ends as necessary

2) matrix exponential when t is very small, and v has 0s in it
seems like the scipy.sparse.linalg.expm_multiply might be more robust in this case
investigate the timing too

***
subclass ndarray, and replace rmul,radd, etc for this subclass!!!!

this will allow arbitrary left,right multiplication etc, and clean up the code a lot! and also allow us to use arbitrary scipy functions, e.g. in the FunctionalTruncatedHistory

***
merge admixture branch into autodiff branch

***
fix overflow errors in exponential growth

to do this, use the fact that
exp(x) * exp1(x) (ie exp(x) * expi(-x))
is approximately equal to 1/x when x is large
(see wikipedia)

better yet, can express everything in terms of
exp(1/x) * exp1(1/x) * x
which is approximately 1 when x is very small
(this further allows us to have a growth rate of 0.0 and not fail)!

***
make exponential size history work with growth rate 0, and also tau=0.
Fix parse_ms TODO: for tau==0.0 case

***
for parse ms, let -es specificy the label of the new population
this will be required to avoid confusion over population labels when fitting times of events

***
compare which version of expm_multiply is faster (with and without derivatives)

****
in adarray, make __pow__ work for arrays, for at least some cases
(e.g. if raising an array to a constant power -- having x**-1 would be nice)
in adarray, implement logical_or, logical_and
in adarray, implement allclose

after above changes, do cleanup in size_history, removing array() and num.x calls where possible
also do cleanup in test_size_history with np.allclose

***
make adarray be able to merge back into original project easily

to do this, instead of using ADF class, change ADF to be abstract superclass
old-ad ADF becomes ADScalar
my new ADF becomes ADArray
whenever ADF arithmetic returns something, it calls self.getAD(result) to make
the result be of appropriate type, where ADScalar and ADArray each return their own
getAD

***
make size_history store the SFS as an array,
instead of having sum_product have to convert to an array everytime

***
Make functional size history work with autodifferentiation! Right now assumes it's a constant function always

***
allow for iteration over adarray objects (useful for passing in *array to demography.from_ms)

***
be consistent with leaves vs leafs (leaves is demography property, leafs is argument to parse_ms)

***
clean up from_newick, to_newick in demography.py

Either:
get rid of it entirely
or
change it to use from_ms
or
implement to_ms, so Demography.simulate_sfs() can work for newick demos

***
for simulate_sfs, make theta=None work when -r is set
(right now it counts up the total branch length, but doesn't know
how to deal with multiple trees)

***
replace cached_property module (v1.0.0 not compatible with using nx.DiGraph)
***
make state of derived counts, a property of SumProduct, instead of Demography
***
don't make n_max a field of size_history;
instead have etjj and sfs take n as a parameter, and return
the appropriate vector

***
add option to simulate from ms instead of scrm

***
test timing of second order derivatives
improve syntax for using second order derivatives

***
test in what regime expm_multiply is better than eigenvalue
internally decide which one to use based on the regime

***
test in what regime fft_convolve is better than convolve
internally decide which one to use based on the regime

***
rename SumProduct.p()

***
improve the syntax for SFS.
use dictionary for state instead of tuple? (downside: won't be hashable)
store sumCounts, sumSqCounts, nonzeroCounts in a single object?

***
try autograd package for automatic differentiation

***
in size_history fix TODO (make deep copy)

***
change everything to be in ms units